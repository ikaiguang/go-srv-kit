// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package authpkg

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
	strconv "strconv"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

func IsUnknown(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_UNKNOWN.String() && e.Code == 401
}

func ErrorUnknown(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_UNKNOWN.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_UNKNOWN.Number()))}
	return e
}

func IsTokenMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_MISSING.String() && e.Code == 401
}

func ErrorTokenMissing(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_MISSING.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_MISSING.Number()))}
	return e
}

func IsTokenKeyMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_KEY_MISSING.String() && e.Code == 401
}

func ErrorTokenKeyMissing(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_KEY_MISSING.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_KEY_MISSING.Number()))}
	return e
}

func IsTokenMethodMissing(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_METHOD_MISSING.String() && e.Code == 401
}

func ErrorTokenMethodMissing(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_METHOD_MISSING.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_METHOD_MISSING.Number()))}
	return e
}

func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_UNAUTHORIZED.String() && e.Code == 401
}

func ErrorUnauthorized(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_UNAUTHORIZED.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_UNAUTHORIZED.Number()))}
	return e
}

func IsTokenExpired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_EXPIRED.String() && e.Code == 401
}

func ErrorTokenExpired(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_EXPIRED.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_EXPIRED.Number()))}
	return e
}

func IsAuthenticationFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_AUTHENTICATION_FAILED.String() && e.Code == 401
}

func ErrorAuthenticationFailed(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_AUTHENTICATION_FAILED.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_AUTHENTICATION_FAILED.Number()))}
	return e
}

func IsTokenInvalid(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_INVALID.String() && e.Code == 401
}

func ErrorTokenInvalid(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_INVALID.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_INVALID.Number()))}
	return e
}

func IsTokenDeprecated(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_DEPRECATED.String() && e.Code == 401
}

func ErrorTokenDeprecated(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_DEPRECATED.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_DEPRECATED.Number()))}
	return e
}

func IsTokenNotInWhitelist(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_TOKEN_NOT_IN_WHITELIST.String() && e.Code == 401
}

func ErrorTokenNotInWhitelist(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_TOKEN_NOT_IN_WHITELIST.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_TOKEN_NOT_IN_WHITELIST.Number()))}
	return e
}

func IsVerificationFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_VERIFICATION_FAILED.String() && e.Code == 401
}

func ErrorVerificationFailed(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_VERIFICATION_FAILED.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_VERIFICATION_FAILED.Number()))}
	return e
}

func IsInvalidClaims(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ERROR_INVALID_CLAIMS.String() && e.Code == 401
}

func ErrorInvalidClaims(format string, args ...interface{}) *errors.Error {
	e := errors.New(401, ERROR_INVALID_CLAIMS.String(), fmt.Sprintf(format, args...))
	e.Metadata = map[string]string{"reason": strconv.Itoa(int(ERROR_INVALID_CLAIMS.Number()))}
	return e
}
